from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
import hashlib
import mimetypes
from datetime import datetime
from PIL import Image  # For cover processing
import io

from fastapi import Depends, HTTPException
from motor.motor_asyncio import AsyncIOMotorDatabase

from database.database import get_db_session
from database import book_crud
from api.v1.schemas.book_schemas import BookCreate, BookUpdate, BookInDB
from core.config import settings

from parsers.base_parser import BookParser
from parsers.epub_parser import EpubParser
from parsers.pdf_parser import PdfParser
# Import other parsers as you create them

PARSER_MAPPING = {
    "EPUB": EpubParser,
    "PDF": PdfParser,
    # "MOBI/AZW": MobiParser, # Add when implemented
}


class Bookservice:
    def __init__(self, db: AsyncIOMotorDatabase = Depends(get_db_session)):
        self.db = db

    async def _get_parser(self, file_path: Path) -> Optional[BookParser]:
        file_format = BookParser.get_file_format(file_path)
        parser_class = PARSER_MAPPING.get(file_format)  # type: ignore
        if parser_class:
            return parser_class()
        return None

    def _generate_file_hash(self, file_path: Path, hash_algo="md5") -> str:
        hasher = hashlib.new(hash_algo)
        with file_path.open("rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hasher.update(chunk)
        return hasher.hexdigest()

    async def process_and_save_book(
        self, file_path: Path, original_filename: str
    ) -> BookInDB:
        # 1. Generate Hash and Check for Duplicates
        file_hash = self._generate_file_hash(file_path)
        existing_book = await book_crud.get_book_by_hash(self.db, file_hash)
        if existing_book:
            # If duplicate, decide on behavior: error, return existing, or update existing.
            # For now, let's assume we don't want exact duplicates based on content hash.
            # Clean up the uploaded temp file
            if file_path.exists():
                file_path.unlink()
            raise HTTPException(
                status_code=409,
                detail=f"Book with same content (hash: {file_hash}) already exists with ID: {existing_book['_id']}",
            )

        # 2. Get Parser
        parser = await self._get_parser(file_path)
        if not parser:
            if file_path.exists():
                file_path.unlink()
            raise HTTPException(
                status_code=415,
                detail=f"Unsupported file format for {original_filename}",
            )

        # 3. Parse Metadata
        extracted_metadata = parser.parse_metadata(file_path)
        if "parsing_error" in extracted_metadata:
            # Handle partial or failed parsing - log it, maybe store minimal info
            print(
                f"Metadata parsing issue for {original_filename}: {extracted_metadata['parsing_error']}"
            )
            # Decide if to proceed or raise error

        # 4. Prepare BookCreate data
        # We'll use extracted_metadata and add system-generated fields
        book_data_to_create: Dict[str, Any] = {
            "original_filename": original_filename,
            "md5_hash": file_hash,
            "file_size_bytes": file_path.stat().st_size,
            "format": extracted_metadata.get(
                "format", parser.get_file_format(file_path)
            ),
            # Map extracted fields to BookCreate schema fields
            "title": extracted_metadata.get("title"),
            "authors": extracted_metadata.get("authors", []),
            "publisher": extracted_metadata.get("publisher"),
            "publication_date": extracted_metadata.get("publication_date"),
            "language": extracted_metadata.get("language"),
            "description": extracted_metadata.get("description"),
            "tags": extracted_metadata.get("tags", []),
            "identifiers": extracted_metadata.get("identifiers", []),
        }
        # Clean None values from book_data_to_create before creating DB object
        book_data_to_create = {
            k: v for k, v in book_data_to_create.items() if v is not None
        }

        # 5. Store Original Book File (using hash as filename to avoid collision)
        # The actual ID will be generated by MongoDB, so using hash for now.
        # A better approach might be to create DB record first, get ID, then name files by ID.
        # For this iteration, we'll name by hash and then link.
        # Or, generate a UUID for filenames.
        import uuid

        book_internal_id_for_filename = str(
            uuid.uuid4()
        )  # Temporary ID for filenames before DB ID

        stored_filename_stem = book_internal_id_for_filename
        stored_file_ext = file_path.suffix
        stored_file_path = (
            settings.BOOK_FILES_DIR / f"{stored_filename_stem}{stored_file_ext}"
        )

        try:
            # Ensure parent directory exists
            settings.BOOK_FILES_DIR.mkdir(parents=True, exist_ok=True)
            file_path.rename(stored_file_path)  # Move the temp file to final storage
        except Exception as e:
            # Clean up if move fails
            if file_path.exists():
                file_path.unlink()
            raise HTTPException(
                status_code=500, detail=f"Could not store book file: {e}"
            )

        book_data_to_create["stored_filename"] = (
            f"{stored_filename_stem}{stored_file_ext}"  # Store relative name
        )

        # 6. Extract, Process, and Store Cover Image
        cover_data_tuple = parser.extract_cover_image_data(
            stored_file_path
        )  # Parse from stored location
        cover_filename = None
        if cover_data_tuple:
            image_bytes, original_mimetype = cover_data_tuple
            try:
                img = Image.open(io.BytesIO(image_bytes))
                # Standardize to JPEG, create thumbnail
                # Main cover
                cover_filename_main = f"{stored_filename_stem}_cover.jpg"
                cover_path_main = settings.COVER_FILES_DIR / cover_filename_main
                img.convert("RGB").save(cover_path_main, "JPEG", quality=85)
                cover_filename = cover_filename_main  # Store this in DB

                # Thumbnail (example)
                # thumb_filename = f"{stored_filename_stem}_thumb.jpg"
                # thumb_path = settings.COVER_FILES_DIR / thumb_filename
                # img.thumbnail((150, 200)) # Resize in place
                # img.convert("RGB").save(thumb_path, "JPEG", quality=80)
            except Exception as e:
                print(f"Could not process/save cover for {original_filename}: {e}")
                # Cover saving failed, but proceed without it

        if cover_filename:
            book_data_to_create["cover_image_filename"] = cover_filename

        # 7. Save Metadata to Database
        created_db_book = await book_crud.create_book_metadata(
            self.db, book_data_to_create
        )

        # Update the stored_filename and cover_filename if you want to rename them using the DB ID
        # db_id = str(created_db_book['_id'])
        # new_stored_filename = f"{db_id}{stored_file_ext}"
        # new_cover_filename = f"{db_id}_cover.jpg" if cover_filename else None
        # TODO: Add logic to rename files using created_db_book['_id'] if desired and update DB record

        return BookInDB.model_validate(created_db_book)

    async def get_multiple_books(
        self, skip: int, limit: int, search_query: Optional[str]
    ) -> Tuple[List[Dict[str, Any]], int]:
        return await book_crud.get_all_books(self.db, skip, limit, search_query)

    async def get_book_by_id(self, book_id: str) -> Optional[Dict[str, Any]]:
        return await book_crud.get_book_by_id(self.db, book_id)

    async def update_book(
        self, book_id: str, book_update_data: BookUpdate
    ) -> Optional[Dict[str, Any]]:
        # TODO: Add logic if cover image needs to be re-processed or files changed
        return await book_crud.update_book_metadata(self.db, book_id, book_update_data)

    async def delete_book_by_id(self, book_id: str) -> int:
        book_to_delete = await book_crud.get_book_by_id(self.db, book_id)
        if not book_to_delete:
            return 0

        # Delete files from storage
        if book_to_delete.get("stored_filename"):
            file_to_delete = settings.BOOK_FILES_DIR / book_to_delete["stored_filename"]
            if file_to_delete.exists():
                file_to_delete.unlink()

        if book_to_delete.get("cover_image_filename"):
            cover_to_delete = (
                settings.COVER_FILES_DIR / book_to_delete["cover_image_filename"]
            )
            if cover_to_delete.exists():
                cover_to_delete.unlink()
            # Also delete thumbnail if you have one

        return await book_crud.delete_book_metadata(self.db, book_id)

    async def get_book_cover_path(
        self, book_id: str
    ) -> Tuple[Optional[Path], Optional[str]]:
        book = await self.get_book_by_id(book_id)
        if book and book.get("cover_image_filename"):
            cover_path = settings.COVER_FILES_DIR / book["cover_image_filename"]
            if cover_path.exists():
                media_type, _ = mimetypes.guess_type(cover_path)
                return cover_path, media_type or "image/jpeg"  # Default mimetype
        return None, None

    async def get_book_file_path_and_details(
        self, book_id: str
    ) -> Tuple[Optional[Path], Optional[str], Optional[str]]:
        book = await self.get_book_by_id(book_id)
        if book and book.get("stored_filename"):
            file_path = settings.BOOK_FILES_DIR / book["stored_filename"]
            if file_path.exists():
                media_type, _ = mimetypes.guess_type(file_path)
                # Common book mimetypes
                if book.get("format") == "EPUB":
                    media_type = media_type or "application/epub+zip"
                elif book.get("format") == "PDF":
                    media_type = media_type or "application/pdf"
                elif book.get("format", "").startswith("MOBI"):
                    media_type = media_type or "application/x-mobipocket-book"

                return (
                    file_path,
                    book.get("original_filename", "book_file"),
                    media_type,
                )
        return None, None, None


# Dependency for router
def get_book_service(
    db: AsyncIOMotorDatabase = Depends(get_db_session),
) -> Bookservice:
    return Bookservice(db)
